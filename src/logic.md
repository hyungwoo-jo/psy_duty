# 스케줄링 로직 설명

이 문서는 당직 스케줄링 시스템이 어떤 흐름과 규칙에 따라 동작하는지 알기 쉽게 설명합니다.

## 개요

스케줄링 시스템의 핵심 목표는, 주어진 모든 규칙과 제약 조건을 만족하면서 모든 근무자에게 최대한 공평한 당직표를 작성하는 것입니다.

이 과정은 "매우 똑똑한 해결사"에게 복잡한 퍼즐을 푸는 것과 같습니다. 우리는 해결사에게 퍼즐의 모든 규칙(예: "A는 B 옆에 올 수 없다")과 목표(예: "모든 조각을 사용해야 한다")를 알려주고, 해결사는 그 규칙을 모두 지키는 최적의 해답을 찾아냅니다. 여기서 '해결사'의 역할을 하는 것이 **ILP(정수 선형 계획법) 솔버**입니다.

## 스케줄링 과정 흐름

스케줄은 다음과 같은 단계를 거쳐 생성됩니다.

1.  **입력 정보 준비:** 사용자가 입력한 시작 날짜, 근무 기간, 근무자 명단, 휴가/휴일 정보, 이전 달의 보정치 등을 시스템이 이해할 수 있는 데이터로 변환합니다.

2.  **규칙(제약 조건) 설정:** 아래 '주요 규칙' 섹션에 설명된 모든 규칙들을 수학적인 형태의 '제약 조건'으로 만듭니다. 예를 들어, "A 근무자는 특정 날에 휴가이므로 당직을 설 수 없다"와 같은 규칙이 포함됩니다.

3.  **ILP 문제 생성 및 해결:** 준비된 데이터와 제약 조건들을 ILP 솔버에게 전달합니다. 솔버는 이 모든 조건을 만족하는 최적의 당직 조합을 계산하여 찾아냅니다.

4.  **결과 생성 및 표시:** 솔버가 찾아낸 수학적인 해답을 사람이 보기 좋은 당직표, 주간 근무 시간 통계, 다음 달 보정치 등의 형태로 가공하여 화면에 보여줍니다.

## 주요 규칙 및 제약 조건

스케줄러는 다음과 같은 핵심 규칙들을 바탕으로 당직을 배정합니다.

### 1. 기본 배정 규칙
- **자격 요건:** 각 당직 슬롯(병당, 응당)에는 해당 날짜와 요일에 맞는 특정 연차(R1~R4)의 근무자만 배정될 수 있습니다.
- **휴가/휴일:** 휴가 또는 당직 불가로 설정된 날에는 해당 근무자에게 당직이 배정되지 않습니다.
- **Day-off 희망:** 특정 날짜에 Day-off를 희망하는 경우, 해당 Day-off를 얻기 위해 **그 전날에 반드시 당직을 서도록** 합니다. 만약 전날 당직이 불가능하면 스케줄 생성이 실패할 수 있습니다.

### 2. 근무 시간 및 공평성 규칙
- **주간 최대 근무 시간:** 모든 근무자의 주간 총 근무 시간(정규 근무 + 당직)은 72시간을 초과하지 않도록 합니다.
- **당직 횟수 분배:** 연차 내에서 모든 근무자가 최대한 비슷한 횟수의 당직(병당, 응당)을 서도록 분배합니다.
- **Day-off 분배:** 평일 당직 다음 날 주어지는 Day-off 횟수 또한 연차 내에서 최대한 공평하게 분배됩니다.
- **이전 달 보정치 적용:** 이전 달에 당직이나 Day-off가 많거나 적었던 것을 보정치로 입력받아, 이번 달 스케줄에 반영하여 여러 달에 걸쳐 공평함이 유지되도록 합니다.

### 3. 3년차(R3) 특별 규칙
- **주 1회 당직 제한:** 3년차는 **주 1회**를 초과하여 당직을 서지 않는 것을 원칙으로 합니다.
- **예외 상황 처리:**
    - 만약 3년차 근무자의 휴가로 인해 이 규칙을 도저히 지킬 수 없는 경우에만, 시스템은 이 규칙을 자동으로 완화하여 스케줄을 생성합니다.
    - 그 외의 경우에는 이 규칙이 **반드시** 지켜집니다. 규칙을 지킬 수 없으면 스케줄 생성이 실패하고 사용자에게 알려줍니다.
- **소아과 수요일 당직 제외:** 소아과 3년차는 수요일에 당직이 배정되지 않습니다.
- **짝수 인원 분배:** 소아과가 아닌 3년차가 2명일 경우, 두 근무자의 병당, 응당, Day-off 횟수가 서로 1회 이상 차이 나지 않도록 최대한 동일하게 맞춥니다.

### ILP 모델 입력값 도출 과정 (사전 계산)

ILP 솔버에 전달되는 제약 조건들은 단순히 고정된 값이 아니라, 사용자의 입력과 스케줄링 기간의 특성(휴일, 요일 등)에 따라 동적으로 계산됩니다. 다음은 주요 입력값들이 어떻게 도출되는지에 대한 설명입니다.

1.  **정규 근무 시간 (`RegularHours_p`)**:
    *   모든 근무자 `p`에 대해, 당직이 없는 날의 정규 근무 시간은 **8시간**으로 고정됩니다.
    *   하지만 근무자 `p`가 당직을 수행한 다음 날이거나, UI에서 'Day-off 희망일'로 지정된 날에는 정규 근무 시간 계산에서 제외됩니다 (즉, 해당 날의 `RegularHours_p`는 **0시간**으로 간주됩니다).
    *   이는 주간 총 근무 시간을 계산할 때, 당직이 없는 평일에 근무자가 8시간 근무한다고 가정하여 합산되지만, Day-off가 부여된 날은 근무하지 않는 것으로 처리됩니다.

2.  **주간 최대 허용 근무 시간 (`C_p`)**:
    *   기본적으로 모든 근무자의 주간 최대 근무 시간은 **72시간**입니다.
    *   하지만 특정 연차(`klass`)의 근무자 중 한 명이라도 해당 주에 휴가가 있다면, 해당 연차의 모든 근무자에 대한 주간 최대 근무 시간은 **80시간**으로 일시적으로 완화됩니다.
    *   또한, 근무자 `p`가 해당 주에 휴가를 사용한 경우, 그 휴가 일수만큼 정규 근무 시간(8시간/일)이 차감되어 `C_p`가 조정됩니다. 이는 휴가로 인해 실제로 근무할 수 있는 시간이 줄어들었음을 반영합니다.
    *   **수학적 표현:**
        `C_p = BaseCap - (VacationDays_p_in_week * RegularHours_per_day)`
        -   `BaseCap`: 기본 72시간 또는 연차 내 휴가자 존재 시 80시간
        -   `VacationDays_p_in_week`: 근무자 `p`가 해당 주에 사용한 휴가 일수
        -   `RegularHours_per_day`: 8시간

3.  **Day-off 최소/최대 허용 횟수 (`MinDO_p`, `MaxDO_p`)**:
    *   Day-off는 평일 당직 다음 날 주어지는 휴무를 의미합니다.
    *   전체 스케줄 기간 동안 발생할 수 있는 총 Day-off 횟수를 계산하고, 이를 Day-off 배정 대상 근무자 수로 나누어 평균 Day-off 횟수를 구합니다.
    *   각 근무자 `p`의 `MinDO_p`는 `평균 Day-off 횟수 - 3`, `MaxDO_p`는 `평균 Day-off 횟수 + 3`으로 설정됩니다. (3년차는 이 규칙에서 제외됩니다.)
    *   **이전 달 보정치 적용:** `MinDO_p`와 `MaxDO_p`는 이전 달로부터 이월된 Day-off 보정치(`CarryoverDO_p`)를 반영하여 조정됩니다.
    *   **수학적 표현:**
        `MinDO_p = floor(AvgDO) - 3 - CarryoverDO_p`
        `MaxDO_p = ceil(AvgDO) + 3 - CarryoverDO_p`
        -   `AvgDO`: 전체 Day-off 횟수 / Day-off 배정 대상 근무자 수
        -   `CarryoverDO_p`: 근무자 `p`의 이전 달 Day-off 보정치

4.  **역할별 당직 최소/최대 허용 횟수 (`MinRole_pr`, `MaxRole_pr`)**:
    *   각 역할(`role`, 예: 병당, 응당)에 대해, 전체 스케줄 기간 동안 필요한 총 당직 횟수를 계산합니다.
    *   이를 해당 역할에 배정 가능한 근무자 수로 나누어 평균 당직 횟수를 구합니다.
    *   각 근무자 `p`의 `MinRole_pr`과 `MaxRole_pr`은 해당 역할의 평균 당직 횟수를 기준으로 일정 범위 내에서 설정됩니다.
    *   **이전 달 보정치 적용:** `MinRole_pr`과 `MaxRole_pr` 또한 이전 달로부터 이월된 해당 역할의 당직 보정치(`CarryoverRole_pr`)를 반영하여 조정됩니다.
    *   **수학적 표현:**
        `MinRole_pr = floor(AvgRole_r) - DeviationLimit_r - CarryoverRole_pr`
        `MaxRole_pr = ceil(AvgRole_r) + DeviationLimit_r - CarryoverRole_pr`
        -   `AvgRole_r`: 역할 `r`의 총 당직 횟수 / 역할 `r` 배정 가능 근무자 수
        -   `DeviationLimit_r`: 역할 `r`에 대한 허용 편차 (일반적으로 1, 완화 모드 시 2)
        -   `CarryoverRole_pr`: 근무자 `p`의 역할 `r`에 대한 이전 달 당직 보정치

5.  **이전 달 보정치 (`CarryoverDO_p`, `CarryoverRole_pr`)**:
    *   사용자가 UI를 통해 직접 입력하거나, 이전 달 스케줄 결과에서 자동으로 계산되어 다음 달 스케줄에 반영됩니다.
    *   이 보정치는 특정 근무자가 이전 달에 평균보다 당직을 더 많이 섰다면 음수(-), 적게 섰다면 양수(+)로 기록되어, 이번 달 스케줄에서 해당 근무자에게 당직을 더 적게/많이 배정하도록 유도합니다.
    *   **계산 방식:**
        1.  이전 달의 각 근무자별 당직 횟수(병당, 응당) 및 Day-off 횟수를 집계합니다.
        2.  각 연차 및 역할별로 근무자들의 횟수를 비교하여 중앙값(median) 또는 최빈값(mode)을 기준으로 삼습니다.
        3.  각 근무자의 횟수와 기준값의 차이(`횟수 - 기준값`)를 보정치로 계산합니다. 이 보정치는 다음 달 스케줄의 제약 조건에 반영되어, 이전 달의 불균형을 해소하는 데 기여합니다.

### ILP 모델의 주요 제약 조건 (수학적 표현)

스케줄링 시스템은 다음 변수와 제약 조건들을 사용하여 최적의 당직표를 계산합니다.

**변수 정의:**
-   `x_pds`: 근무자 `p`가 날짜 `d`의 슬롯 `s`에 배정되면 1, 아니면 0 (이진 변수)
    -   `p`: 근무자 ID
    -   `d`: 날짜 인덱스 (0부터 시작)
    -   `s`: 슬롯 인덱스 (0: 병당, 1: 응당)

**주요 제약 조건:**

1.  **모든 슬롯은 채워져야 한다:**
    -   각 날짜 `d`의 각 슬롯 `s`는 정확히 한 명의 근무자에게 배정되어야 합니다.
    -   `SUM_p (x_pds) = 1` (모든 `d`, `s`에 대해)

2.  **근무자별 일일 최대 당직 횟수 (연속 당직 금지 포함):**
    -   어떤 근무자 `p`도 특정 날짜 `d`에 1개 이상의 당직을 맡을 수 없습니다.
    -   `SUM_s (x_pds) <= 1` (모든 `p`, `d`에 대해)
    -   또한, 근무자 `p`가 날짜 `d`에 당직을 맡았다면, 날짜 `d+1`에는 당직을 맡을 수 없습니다.
    -   `SUM_s (x_pds) + SUM_s (x_p(d+1)s) <= 1` (모든 `p`, `d`에 대해)

3.  **Day-off 희망 (강제 당직):**
    -   근무자 `p`가 날짜 `D_off`에 Day-off를 희망하는 경우, `D_off`의 전날 `D_prev`에 반드시 당직을 맡아야 합니다.
    -   `SUM_s (x_p(D_prev)s) = 1` (모든 `p`, `D_prev`에 대해, `D_prev`는 희망 Day-off의 전날)

4.  **주간 최대 근무 시간:**
    -   근무자 `p`의 주간 총 근무 시간은 `C_p` 시간을 초과할 수 없습니다.
    -   `SUM_d_in_week( SUM_s (x_pds * DutyHours_s) + RegularHours_p ) <= C_p` (모든 `p`, `week`에 대해)
        -   `DutyHours_s`: 슬롯 `s`의 당직 시간 (평일/주말에 따라 다름)
        -   `RegularHours_p`: 근무자 `p`의 정규 근무 시간 (당직이 없는 날)
        -   `C_p`: 근무자 `p`의 주간 최대 허용 근무 시간 (기본 72시간, 휴가 시 조정)

4.  **3년차(R3) 주간 당직 횟수 제한:**
    -   3년차 근무자 `p`는 특정 주 `week`에 1회 초과하여 당직을 맡을 수 없습니다.
    -   `SUM_d_in_week( SUM_s (x_pds) ) <= 1` (모든 R3 근무자 `p`, `week`에 대해)

5.  **Day-off 균형:**
    -   근무자 `p`의 Day-off 횟수는 `MinDO_p`와 `MaxDO_p` 사이에 있어야 합니다.
    -   `MinDO_p <= DayOffCount_p <= MaxDO_p` (모든 `p`에 대해)
        -   `DayOffCount_p`: 근무자 `p`의 총 Day-off 횟수
        -   `MinDO_p`, `MaxDO_p`: 근무자 `p`의 최소/최대 허용 Day-off 횟수 (평균 기반, 보정치 적용)

6.  **역할별 당직 횟수 균형:**
    -   근무자 `p`의 특정 역할 `role` (병당/응당) 당직 횟수는 `MinRole_pr`와 `MaxRole_pr` 사이에 있어야 합니다.
    -   `MinRole_pr <= RoleDutyCount_pr <= MaxRole_pr` (모든 `p`, `role`에 대해)
        -   `RoleDutyCount_pr`: 근무자 `p`의 역할 `role`에 대한 총 당직 횟수
        -   `MinRole_pr`, `MaxRole_pr`: 근무자 `p`의 역할 `role`에 대한 최소/최대 허용 당직 횟수 (평균 기반, 보정치 적용)

## 최적화 및 재시도 로직

최초 스케줄이 생성된 후에도, 시스템은 더 나은 결과를 찾기 위해 여러 번의 재시도를 수행합니다.

- **초기 생성:** 먼저 위에서 설명한 모든 규칙(R3 주 1회 제한 포함)을 적용하여 첫 스케줄을 생성합니다.
- **실패 시 완화:** 만약 R3의 휴가 등으로 인해 규칙을 지킬 수 없어 첫 생성이 실패하면, R3 주 1회 제한 규칙만 완화하여 다시 시도합니다.
- **반복 최적화:** 생성이 성공하면, 시스템은 정해진 횟수(최대 50회)만큼 재시도를 반복하며 다음과 같은 목표를 달성하려고 노력합니다.
    1.  주간 근무시간 72시간 초과 최소화
    2.  연차 내 당직 횟수 편차 최소화
    3.  비어있는 당직 슬롯 최소화
- 이 과정에서 이전에 찾은 해보다 더 공평하고 규칙을 잘 지키는 해를 찾으면, 그것을 최종 결과로 선택합니다. 재시도 시에도 R3 주 1회 제한 규칙은 (가능한 경우) 계속 적용됩니다.
